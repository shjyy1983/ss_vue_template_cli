var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { Stack } from '@glimmer/util';
export var SymbolAllocator = function () {
    function SymbolAllocator(ops) {
        _classCallCheck(this, SymbolAllocator);

        this.ops = ops;
        this.symbolStack = new Stack();
    }

    SymbolAllocator.prototype.process = function process() {
        var out = [];
        var ops = this.ops;

        for (var i = 0; i < ops.length; i++) {
            var op = ops[i];
            var result = this.dispatch(op);
            if (result === undefined) {
                out.push(op);
            } else {
                out.push(result);
            }
        }
        return out;
    };

    SymbolAllocator.prototype.dispatch = function dispatch(op) {
        var name = op[0];
        var operand = op[1];
        return this[name](operand);
    };

    SymbolAllocator.prototype.startProgram = function startProgram(op) {
        this.symbolStack.push(op.symbols);
    };

    SymbolAllocator.prototype.endProgram = function endProgram(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.startBlock = function startBlock(op) {
        this.symbolStack.push(op.symbols);
    };

    SymbolAllocator.prototype.endBlock = function endBlock(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.openNamedBlock = function openNamedBlock(op) {
        this.symbolStack.push(op.symbols);
    };

    SymbolAllocator.prototype.closeNamedBlock = function closeNamedBlock(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.flushElement = function flushElement(op) {
        this.symbolStack.push(op.symbols);
    };

    SymbolAllocator.prototype.closeElement = function closeElement(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeComponent = function closeComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeDynamicComponent = function closeDynamicComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.attrSplat = function attrSplat(_op) {
        return ['attrSplat', this.symbols.allocateBlock('attrs')];
    };

    SymbolAllocator.prototype.get = function get(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head = this.symbols.allocateNamed(name);
            return ['get', [_head, rest]];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.maybeGet = function maybeGet(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head2 = this.symbols.allocateNamed(name);
            return ['get', [_head2, rest]];
        } else if (rest.length === 0) {
            return ['unknown', name];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.yield = function _yield(op) {
        if (op === 0) {
            throw new Error('Cannot yield to this');
        }
        return ['yield', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.debugger = function _debugger(_op) {
        return ['debugger', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.hasBlock = function hasBlock(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlock this');
        }
        return ['hasBlock', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.hasBlockParams = function hasBlockParams(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlockParams this');
        }
        return ['hasBlockParams', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.partial = function partial(_op) {
        return ['partial', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.text = function text(_op) {};

    SymbolAllocator.prototype.comment = function comment(_op) {};

    SymbolAllocator.prototype.openComponent = function openComponent(_op) {};

    SymbolAllocator.prototype.openElement = function openElement(_op) {};

    SymbolAllocator.prototype.staticArg = function staticArg(_op) {};

    SymbolAllocator.prototype.dynamicArg = function dynamicArg(_op) {};

    SymbolAllocator.prototype.staticAttr = function staticAttr(_op) {};

    SymbolAllocator.prototype.trustingAttr = function trustingAttr(_op) {};

    SymbolAllocator.prototype.dynamicAttr = function dynamicAttr(_op) {};

    SymbolAllocator.prototype.componentAttr = function componentAttr(_op) {};

    SymbolAllocator.prototype.trustingComponentAttr = function trustingComponentAttr(_op) {};

    SymbolAllocator.prototype.modifier = function modifier(_op) {};

    SymbolAllocator.prototype.append = function append(_op) {};

    SymbolAllocator.prototype.block = function block(_op) {};

    SymbolAllocator.prototype.literal = function literal(_op) {};

    SymbolAllocator.prototype.helper = function helper(_op) {};

    SymbolAllocator.prototype.unknown = function unknown(_op) {};

    SymbolAllocator.prototype.maybeLocal = function maybeLocal(_op) {};

    SymbolAllocator.prototype.prepareArray = function prepareArray(_op) {};

    SymbolAllocator.prototype.prepareObject = function prepareObject(_op) {};

    SymbolAllocator.prototype.concat = function concat(_op) {};

    _createClass(SymbolAllocator, [{
        key: 'symbols',
        get: function get() {
            return this.symbolStack.current;
        }
    }]);

    return SymbolAllocator;
}();
function isLocal(name, symbols) {
    return symbols && symbols.has(name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9hbGxvY2F0ZS1zeW1ib2xzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxTQUFBLEtBQUEsUUFBQSxlQUFBO0FBZ0JBLFdBQU0sZUFBTjtBQUlFLDZCQUFBLEdBQUEsRUFBb0M7QUFBQTs7QUFBaEIsYUFBQSxHQUFBLEdBQUEsR0FBQTtBQUZaLGFBQUEsV0FBQSxHQUFjLElBQWQsS0FBYyxFQUFkO0FBRWdDOztBQUoxQyw4QkFNRSxPQU5GLHNCQU1TO0FBQ0wsWUFBSSxNQUFKLEVBQUE7QUFESyxZQUVELEdBRkMsR0FFTCxJQUZLLENBRUQsR0FGQzs7QUFJTCxhQUFLLElBQUksSUFBVCxDQUFBLEVBQWdCLElBQUksSUFBcEIsTUFBQSxFQUFBLEdBQUEsRUFBcUM7QUFDbkMsZ0JBQUksS0FBSyxJQUFULENBQVMsQ0FBVDtBQUNBLGdCQUFJLFNBQVMsS0FBQSxRQUFBLENBQWIsRUFBYSxDQUFiO0FBRUEsZ0JBQUksV0FBSixTQUFBLEVBQTBCO0FBQ3hCLG9CQUFBLElBQUEsQ0FBQSxFQUFBO0FBREYsYUFBQSxNQUVPO0FBQ0wsb0JBQUEsSUFBQSxDQUFBLE1BQUE7QUFDRDtBQUNGO0FBRUQsZUFBQSxHQUFBO0FBQ0QsS0F0Qkg7O0FBQUEsOEJBd0JFLFFBeEJGLHFCQXdCRSxFQXhCRixFQXdCZ0M7QUFDNUIsWUFBSSxPQUFPLEdBQVgsQ0FBVyxDQUFYO0FBQ0EsWUFBSSxVQUFVLEdBQWQsQ0FBYyxDQUFkO0FBRUEsZUFBUSxLQUFBLElBQUEsRUFBUixPQUFRLENBQVI7QUFDRCxLQTdCSDs7QUFBQSw4QkFtQ0UsWUFuQ0YseUJBbUNFLEVBbkNGLEVBbUMrQjtBQUMzQixhQUFBLFdBQUEsQ0FBQSxJQUFBLENBQXNCLEdBQXRCLE9BQUE7QUFDRCxLQXJDSDs7QUFBQSw4QkF1Q0UsVUF2Q0YsdUJBdUNFLEdBdkNGLEVBdUNzQjtBQUNsQixhQUFBLFdBQUEsQ0FBQSxH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QUFJLENBcEt4Qjs7QUFBQSw4QkFxS0UsT0FyS0Ysb0JBcUtFLEdBcktGLEVBcUtxQixDQUFJLENBckt6Qjs7QUFBQSw4QkFzS0UsVUF0S0YsdUJBc0tFLEdBdEtGLEVBc0swQixDQUFJLENBdEs5Qjs7QUFBQSw4QkF1S0UsWUF2S0YseUJBdUtFLEdBdktGLEVBdUswQixDQUFJLENBdks5Qjs7QUFBQSw4QkF3S0UsYUF4S0YsMEJBd0tFLEdBeEtGLEVBd0syQixDQUFJLENBeEsvQjs7QUFBQSw4QkF5S0UsTUF6S0YsbUJBeUtFLEdBektGLEVBeUtrQixDQUFJLENBekt0Qjs7QUFBQTtBQUFBO0FBQUEsNEJBK0JhO0FBQ1QsbUJBQWMsS0FBQSxXQUFBLENBQWQsT0FBQTtBQUNEO0FBakNIOztBQUFBO0FBQUE7QUE0S0EsU0FBQSxPQUFBLENBQUEsSUFBQSxFQUFBLE9BQUEsRUFBbUQ7QUFDakQsV0FBTyxXQUFXLFFBQUEsR0FBQSxDQUFsQixJQUFrQixDQUFsQjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcGlsZXJPcHMsIFByb2Nlc3NvciwgT3AsIE9wTmFtZSwgVGVtcGxhdGVDb21waWxlck9wcywgUGF0aEhlYWQgfSBmcm9tICcuL2NvbXBpbGVyLW9wcyc7XG5pbXBvcnQgeyBBU1QgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTdGFjaywgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCB0eXBlIEluVmFyaWFibGUgPSBQYXRoSGVhZDtcbmV4cG9ydCB0eXBlIE91dFZhcmlhYmxlID0gbnVtYmVyO1xuXG5leHBvcnQgdHlwZSBPdXRPcDxLIGV4dGVuZHMga2V5b2YgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+ID0gT3BOYW1lPiA9IE9wPFxuICBPdXRWYXJpYWJsZSxcbiAgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+LFxuICBLXG4+O1xuZXhwb3J0IHR5cGUgSW5PcDxLIGV4dGVuZHMga2V5b2YgVGVtcGxhdGVDb21waWxlck9wcyA9IGtleW9mIFRlbXBsYXRlQ29tcGlsZXJPcHM+ID0gT3A8XG4gIFBhdGhIZWFkLFxuICBUZW1wbGF0ZUNvbXBpbGVyT3BzLFxuICBLXG4+O1xuXG5leHBvcnQgY2xhc3MgU3ltYm9sQWxsb2NhdG9yXG4gIGltcGxlbWVudHMgUHJvY2Vzc29yPENvbXBpbGVyT3BzPEluVmFyaWFibGU+LCBPdXRWYXJpYWJsZSwgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+PiB7XG4gIHByaXZhdGUgc3ltYm9sU3RhY2sgPSBuZXcgU3RhY2s8QVNULlN5bWJvbHM+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHM6IEFycmF5PEluT3A+KSB7fVxuXG4gIHByb2Nlc3MoKTogT3V0T3BbXSB7XG4gICAgbGV0IG91dDogT3V0T3BbXSA9IFtdO1xuICAgIGxldCB7IG9wcyB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3AgPSBvcHNbaV07XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kaXNwYXRjaChvcCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQucHVzaChvcCBhcyBPdXRPcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQucHVzaChyZXN1bHQgYXMgYW55KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZGlzcGF0Y2g8TyBleHRlbmRzIEluT3A+KG9wOiBPKTogdW5rbm93biB7XG4gICAgbGV0IG5hbWUgPSBvcFswXTtcbiAgICBsZXQgb3BlcmFuZCA9IG9wWzFdO1xuXG4gICAgcmV0dXJuICh0aGlzW25hbWVdIGFzIGFueSkob3BlcmFuZCk7XG4gIH1cblxuICBnZXQgc3ltYm9scygpOiBBU1QuU3ltYm9scyB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLnN5bWJvbFN0YWNrLmN1cnJlbnQsICdFeHBlY3RlZCBhIHN5bWJvbCB0YWJsZSBvbiB0aGUgc3RhY2snKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZ3JhbShvcDogQVNULlRlbXBsYXRlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wdXNoKG9wLnN5bWJvbHMhKTtcbiAgfVxuXG4gIGVuZFByb2dyYW0oX29wOiBudWxsKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIHN0YXJ0QmxvY2sob3A6IEFTVC5CbG9jaykge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChvcC5zeW1ib2xzISk7XG4gIH1cblxuICBlbmRCbG9jayhfb3A6IG51bGwpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgb3Blbk5hbWVkQmxvY2sob3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChvcC5zeW1ib2xzISk7XG4gIH1cblxuICBjbG9zZU5hbWVkQmxvY2soX29wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgZmx1c2hFbGVtZW50KG9wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnB1c2gob3Auc3ltYm9scyEpO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGNsb3NlQ29tcG9uZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGNsb3NlRHluYW1pY0NvbXBvbmVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBhdHRyU3BsYXQoX29wOiBPcHRpb248SW5WYXJpYWJsZT4pOiBPdXRPcDwnYXR0clNwbGF0Jz4ge1xuICAgIHJldHVybiBbJ2F0dHJTcGxhdCcsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKCdhdHRycycpXTtcbiAgfVxuXG4gIGdldChvcDogW0luVmFyaWFibGUsIHN0cmluZ1tdXSk6IE91dE9wPCdnZXQnIHwgJ21heWJlTG9jYWwnPiB7XG4gICAgbGV0IFtuYW1lLCByZXN0XSA9IG9wO1xuXG4gICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgIHJldHVybiBbJ2dldCcsIFswLCByZXN0XV07XG4gICAgfVxuXG4gICAgaWYgKGlzTG9jYWwobmFtZSwgdGhpcy5zeW1ib2xzKSkge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuZ2V0KG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2UgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuYWxsb2NhdGVOYW1lZChuYW1lKTtcbiAgICAgIHJldHVybiBbJ2dldCcsIFtoZWFkLCByZXN0XV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbJ21heWJlTG9jYWwnLCBbbmFtZSwgLi4ucmVzdF1dO1xuICAgIH1cbiAgfVxuXG4gIG1heWJlR2V0KG9wOiBbSW5WYXJpYWJsZSwgc3RyaW5nW11dKTogT3V0T3A8J2dldCcgfCAndW5rbm93bicgfCAnbWF5YmVMb2NhbCc+IHtcbiAgICBsZXQgW25hbWUsIHJlc3RdID0gb3A7XG5cbiAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFsnZ2V0JywgWzAsIHJlc3RdXTtcbiAgICB9XG5cbiAgICBpZiAoaXNMb2NhbChuYW1lLCB0aGlzLnN5bWJvbHMpKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5nZXQobmFtZSk7XG4gICAgICByZXR1cm4gWydnZXQnLCBbaGVhZCwgcmVzdF1dO1xuICAgIH0gZWxzZSBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2UgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWyd1bmtub3duJywgbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbJ21heWJlTG9jYWwnLCBbbmFtZSwgLi4ucmVzdF1dO1xuICAgIH1cbiAgfVxuXG4gIHlpZWxkKG9wOiBJblZhcmlhYmxlKTogT3V0T3A8J3lpZWxkJz4ge1xuICAgIGlmIChvcCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgeWllbGQgdG8gdGhpcycpO1xuICAgIH1cblxuICAgIHJldHVybiBbJ3lpZWxkJywgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2sob3ApXTtcbiAgfVxuXG4gIGRlYnVnZ2VyKF9vcDogT3B0aW9uPEluVmFyaWFibGVbXT4pOiBPdXRPcDwnZGVidWdnZXInPiB7XG4gICAgcmV0dXJuIFsnZGVidWdnZXInLCB0aGlzLnN5bWJvbHMuZ2V0RXZhbEluZm8oKV07XG4gIH1cblxuICBoYXNCbG9jayhvcDogSW5WYXJpYWJsZSk6IE91dE9wPCdoYXNCbG9jayc+IHtcbiAgICBpZiAob3AgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhc0Jsb2NrIHRoaXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWydoYXNCbG9jaycsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG9wKV07XG4gIH1cblxuICBoYXNCbG9ja1BhcmFtcyhvcDogSW5WYXJpYWJsZSk6IE91dE9wPCdoYXNCbG9ja1BhcmFtcyc+IHtcbiAgICBpZiAob3AgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhc0Jsb2NrUGFyYW1zIHRoaXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWydoYXNCbG9ja1BhcmFtcycsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG9wKV07XG4gIH1cblxuICBwYXJ0aWFsKF9vcDogT3B0aW9uPEluVmFyaWFibGVbXT4pOiBPdXRPcDwncGFydGlhbCc+IHtcbiAgICByZXR1cm4gWydwYXJ0aWFsJywgdGhpcy5zeW1ib2xzLmdldEV2YWxJbmZvKCldO1xuICB9XG5cbiAgdGV4dChfb3A6IHN0cmluZykge31cbiAgY29tbWVudChfb3A6IHN0cmluZykge31cbiAgb3BlbkNvbXBvbmVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge31cbiAgb3BlbkVsZW1lbnQoX29wOiBbQVNULkVsZW1lbnROb2RlLCBib29sZWFuXSkge31cbiAgc3RhdGljQXJnKF9vcDogc3RyaW5nKSB7fVxuICBkeW5hbWljQXJnKF9vcDogc3RyaW5nKSB7fVxuICBzdGF0aWNBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICB0cnVzdGluZ0F0dHIoX29wOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHt9XG4gIGR5bmFtaWNBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICBjb21wb25lbnRBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICB0cnVzdGluZ0NvbXBvbmVudEF0dHIoX29wOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHt9XG4gIG1vZGlmaWVyKF9vcDogc3RyaW5nKSB7fVxuICBhcHBlbmQoX29wOiBib29sZWFuKSB7fVxuICBibG9jayhfb3A6IFtzdHJpbmcsIG51bWJlciwgT3B0aW9uPG51bWJlcj5dKSB7fVxuICBsaXRlcmFsKF9vcDogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpIHt9XG4gIGhlbHBlcihfb3A6IHN0cmluZykge31cbiAgdW5rbm93bihfb3A6IHN0cmluZykge31cbiAgbWF5YmVMb2NhbChfb3A6IHN0cmluZ1tdKSB7fVxuICBwcmVwYXJlQXJyYXkoX29wOiBudW1iZXIpIHt9XG4gIHByZXBhcmVPYmplY3QoX29wOiBudW1iZXIpIHt9XG4gIGNvbmNhdChfb3A6IG51bGwpIHt9XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwobmFtZTogc3RyaW5nLCBzeW1ib2xzOiBBU1QuU3ltYm9scyk6IGJvb2xlYW4ge1xuICByZXR1cm4gc3ltYm9scyAmJiBzeW1ib2xzLmhhcyhuYW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=