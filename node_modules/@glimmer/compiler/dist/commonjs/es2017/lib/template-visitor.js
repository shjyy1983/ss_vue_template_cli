'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockSymbolTable = exports.ProgramSymbolTable = exports.SymbolTable = undefined;

var _util = require('@glimmer/util');

class SymbolTable {
    static top() {
        return new ProgramSymbolTable();
    }
    child(locals) {
        let symbols = locals.map(name => this.allocate(name));
        return new BlockSymbolTable(this, locals, symbols);
    }
}
exports.SymbolTable = SymbolTable;
class ProgramSymbolTable extends SymbolTable {
    constructor() {
        super(...arguments);
        this.symbols = [];
        this.size = 1;
        this.named = (0, _util.dict)();
        this.blocks = (0, _util.dict)();
    }
    has(_name) {
        return false;
    }
    get(_name) {
        throw (0, _util.unreachable)();
    }
    getLocalsMap() {
        return {};
    }
    getEvalInfo() {
        return [];
    }
    allocateNamed(name) {
        let named = this.named[name];
        if (!named) {
            named = this.named[name] = this.allocate(name);
        }
        return named;
    }
    allocateBlock(name) {
        if (name === 'inverse') {
            name = 'else';
        }
        let block = this.blocks[name];
        if (!block) {
            block = this.blocks[name] = this.allocate(`&${name}`);
        }
        return block;
    }
    allocate(identifier) {
        this.symbols.push(identifier);
        return this.size++;
    }
}
exports.ProgramSymbolTable = ProgramSymbolTable;
class BlockSymbolTable extends SymbolTable {
    constructor(parent, symbols, slots) {
        super();
        this.parent = parent;
        this.symbols = symbols;
        this.slots = slots;
    }
    has(name) {
        return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    }
    get(name) {
        let slot = this.symbols.indexOf(name);
        return slot === -1 ? this.parent.get(name) : this.slots[slot];
    }
    getLocalsMap() {
        let dict = this.parent.getLocalsMap();
        this.symbols.forEach(symbol => dict[symbol] = this.get(symbol));
        return dict;
    }
    getEvalInfo() {
        let locals = this.getLocalsMap();
        return Object.keys(locals).map(symbol => locals[symbol]);
    }
    allocateNamed(name) {
        return this.parent.allocateNamed(name);
    }
    allocateBlock(name) {
        return this.parent.allocateBlock(name);
    }
    allocate(identifier) {
        return this.parent.allocate(identifier);
    }
}
exports.BlockSymbolTable = BlockSymbolTable; /**
                                              * Takes in an AST and outputs a list of actions to be consumed
                                              * by a compiler. For example, the template
                                              *
                                              *     foo{{bar}}<div>baz</div>
                                              *
                                              * produces the actions
                                              *
                                              *     [['startProgram', [programNode, 0]],
                                              *      ['text', [textNode, 0, 3]],
                                              *      ['mustache', [mustacheNode, 1, 3]],
                                              *      ['openElement', [elementNode, 2, 3, 0]],
                                              *      ['text', [textNode, 0, 1]],
                                              *      ['closeElement', [elementNode, 2, 3],
                                              *      ['endProgram', [programNode]]]
                                              *
                                              * This visitor walks the AST depth first and backwards. As
                                              * a result the bottom-most child template will appear at the
                                              * top of the actions list whereas the root template will appear
                                              * at the bottom of the list. For example,
                                              *
                                              *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
                                              *
                                              * produces the actions
                                              *
                                              *     [['startProgram', [programNode, 0]],
                                              *      ['text', [textNode, 0, 2, 0]],
                                              *      ['openElement', [elementNode, 1, 2, 0]],
                                              *      ['closeElement', [elementNode, 1, 2]],
                                              *      ['endProgram', [programNode]],
                                              *      ['startProgram', [programNode, 0]],
                                              *      ['text', [textNode, 0, 1]],
                                              *      ['endProgram', [programNode]],
                                              *      ['startProgram', [programNode, 2]],
                                              *      ['openElement', [elementNode, 0, 1, 1]],
                                              *      ['block', [blockNode, 0, 1]],
                                              *      ['closeElement', [elementNode, 0, 1]],
                                              *      ['endProgram', [programNode]]]
                                              *
                                              * The state of the traversal is maintained by a stack of frames.
                                              * Whenever a node with children is entered (either a ProgramNode
                                              * or an ElementNode) a frame is pushed onto the stack. The frame
                                              * contains information about the state of the traversal of that
                                              * node. For example,
                                              *
                                              *   - index of the current child node being visited
                                              *   - the number of mustaches contained within its child nodes
                                              *   - the list of actions generated by its child nodes
                                              */

class Frame {
    constructor() {
        this.parentNode = null;
        this.children = null;
        this.childIndex = null;
        this.childCount = null;
        this.childTemplateCount = 0;
        this.mustacheCount = 0;
        this.actions = [];
        this.blankChildTextNodes = null;
        this.symbols = null;
    }
}
class TemplateVisitor {
    constructor() {
        this.frameStack = [];
        this.actions = [];
        this.programDepth = -1;
    }
    visit(node) {
        this[node.type](node);
    }
    // Traversal methods
    Block(program) {
        return this.anyBlock(program);
    }
    Template(program) {
        return this.anyBlock(program);
    }
    anyBlock(program) {
        this.programDepth++;
        let parentFrame = this.getCurrentFrame();
        let programFrame = this.pushFrame();
        if (!parentFrame) {
            program.symbols = SymbolTable.top();
        } else {
            program.symbols = parentFrame.symbols.child(program.blockParams);
        }
        let startType, endType;
        if (this.programDepth === 0) {
            startType = 'startProgram';
            endType = 'endProgram';
        } else {
            startType = 'startBlock';
            endType = 'endBlock';
        }
        programFrame.parentNode = program;
        programFrame.children = program.body;
        programFrame.childCount = program.body.length;
        programFrame.blankChildTextNodes = [];
        programFrame.actions.push([endType, [program, this.programDepth]]);
        programFrame.symbols = program['symbols'];
        for (let i = program.body.length - 1; i >= 0; i--) {
            programFrame.childIndex = i;
            this.visit(program.body[i]);
        }
        programFrame.actions.push([startType, [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
        this.popFrame();
        this.programDepth--;
        // Push the completed template into the global actions list
        if (parentFrame) {
            parentFrame.childTemplateCount++;
        }
        this.actions.push(...programFrame.actions.reverse());
    }
    ElementNode(element) {
        let parentFrame = this.currentFrame;
        let elementFrame = this.pushFrame();
        elementFrame.parentNode = element;
        elementFrame.children = element.children;
        elementFrame.childCount = element.children.length;
        elementFrame.mustacheCount += element.modifiers.length;
        elementFrame.blankChildTextNodes = [];
        elementFrame.symbols = element.symbols = parentFrame.symbols.child(element.blockParams);
        let actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];
        elementFrame.actions.push(['closeElement', actionArgs]);
        for (let i = element.attributes.length - 1; i >= 0; i--) {
            this.visit(element.attributes[i]);
        }
        for (let i = element.children.length - 1; i >= 0; i--) {
            elementFrame.childIndex = i;
            this.visit(element.children[i]);
        }
        let open = ['openElement', [...actionArgs, elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()]];
        elementFrame.actions.push(open);
        this.popFrame();
        // Propagate the element's frame state to the parent frame
        if (elementFrame.mustacheCount > 0) {
            parentFrame.mustacheCount++;
        }
        parentFrame.childTemplateCount += elementFrame.childTemplateCount;
        parentFrame.actions.push(...elementFrame.actions);
    }
    AttrNode(attr) {
        if (attr.value.type !== 'TextNode') {
            this.currentFrame.mustacheCount++;
        }
    }
    TextNode(text) {
        let frame = this.currentFrame;
        if (text.chars === '') {
            frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
        }
        frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
    }
    BlockStatement(node) {
        let frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);
        if (node.inverse) {
            this.visit(node.inverse);
        }
        if (node.program) {
            this.visit(node.program);
        }
    }
    PartialStatement(node) {
        let frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
    }
    CommentStatement(text) {
        let frame = this.currentFrame;
        frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
    }
    MustacheCommentStatement() {
        // Intentional empty: Handlebars comments should not affect output.
    }
    MustacheStatement(mustache) {
        let frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
    }
    // Frame helpers
    get currentFrame() {
        return this.getCurrentFrame();
    }
    getCurrentFrame() {
        return this.frameStack[this.frameStack.length - 1];
    }
    pushFrame() {
        let frame = new Frame();
        this.frameStack.push(frame);
        return frame;
    }
    popFrame() {
        return this.frameStack.pop();
    }
}
exports.default = TemplateVisitor; // Returns the index of `domNode` in the `nodes` array, skipping
// over any nodes which do not represent DOM nodes.

function domIndexOf(nodes, domNode) {
    let index = -1;
    for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
            continue;
        } else {
            index++;
        }
        if (node === domNode) {
            return index;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi90ZW1wbGF0ZS12aXNpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUlNLE1BQUEsV0FBQSxDQUEyQjtBQUMvQixXQUFBLEdBQUEsR0FBVTtBQUNSLGVBQU8sSUFBUCxrQkFBTyxFQUFQO0FBQ0Q7QUFZRCxVQUFBLE1BQUEsRUFBc0I7QUFDcEIsWUFBSSxVQUFVLE9BQUEsR0FBQSxDQUFXLFFBQVEsS0FBQSxRQUFBLENBQWpDLElBQWlDLENBQW5CLENBQWQ7QUFDQSxlQUFPLElBQUEsZ0JBQUEsQ0FBQSxJQUFBLEVBQUEsTUFBQSxFQUFQLE9BQU8sQ0FBUDtBQUNEO0FBbEI4QjtRQUEzQixXLEdBQUEsVztBQXFCQSxNQUFBLGtCQUFBLFNBQUEsV0FBQSxDQUE2QztBQUFuRCxrQkFBQTs7QUFDUyxhQUFBLE9BQUEsR0FBQSxFQUFBO0FBRUMsYUFBQSxJQUFBLEdBQUEsQ0FBQTtBQUNBLGFBQUEsS0FBQSxHQUFBLGlCQUFBO0FBQ0EsYUFBQSxNQUFBLEdBQUEsaUJBQUE7QUE4Q1Q7QUE1Q0MsUUFBQSxLQUFBLEVBQWlCO0FBQ2YsZUFBQSxLQUFBO0FBQ0Q7QUFFRCxRQUFBLEtBQUEsRUFBaUI7QUFDZixjQUFBLHdCQUFBO0FBQ0Q7QUFFRCxtQkFBWTtBQUNWLGVBQUEsRUFBQTtBQUNEO0FBRUQsa0JBQVc7QUFDVCxlQUFBLEVBQUE7QUFDRDtBQUVELGtCQUFBLElBQUEsRUFBMEI7QUFDeEIsWUFBSSxRQUFRLEtBQUEsS0FBQSxDQUFaLElBQVksQ0FBWjtBQUVBLFlBQUksQ0FBSixLQUFBLEVBQVk7QUFDVixvQkFBUSxLQUFBLEtBQUEsQ0FBQSxJQUFBLElBQW1CLEtBQUEsUUFBQSxDQUEzQixJQUEyQixDQUEzQjtBQUNEO0FBRUQsZUFBQSxLQUFBO0FBQ0Q7QUFFRCxrQkFBQSxJQUFBLEVBQTBCO0FBQ3hCLFlBQUksU0FBSixTQUFBLEVBQXdCO0FBQ3RC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QVo7QUFDQSxhQUFBLFVBQUEsQ0FBQSxJQUFBLENBQUEsS0FBQTtBQUNBLGVBQUEsS0FBQTtBQUNEO0FBRU8sZUFBUTtBQUNkLGVBQU8sS0FBQSxVQUFBLENBQVAsR0FBTyxFQUFQO0FBQ0Q7QUFuTGlDO2tCQUF0QixlLEVBc0xkO0FBQ0E7O0FBQ0EsU0FBQSxVQUFBLENBQUEsS0FBQSxFQUFBLE9BQUEsRUFBOEU7QUFDNUUsUUFBSSxRQUFRLENBQVosQ0FBQTtBQUVBLFNBQUssSUFBSSxJQUFULENBQUEsRUFBZ0IsSUFBSSxNQUFwQixNQUFBLEVBQUEsR0FBQSxFQUF1QztBQUNyQyxZQUFJLE9BQU8sTUFBWCxDQUFXLENBQVg7QUFFQSxZQUFJLEtBQUEsSUFBQSxLQUFBLFVBQUEsSUFBNEIsS0FBQSxJQUFBLEtBQWhDLGFBQUEsRUFBNkQ7QUFDM0Q7QUFERixTQUFBLE1BRU87QUFDTDtBQUNEO0FBRUQsWUFBSSxTQUFKLE9BQUEsRUFBc0I7QUFDcEIsbUJBQUEsS0FBQTtBQUNEO0FBQ0Y7QUFFRCxXQUFPLENBQVAsQ0FBQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IE9wdGlvbiwgZGljdCwgdW5yZWFjaGFibGUsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ29yZSwgRGljdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3ltYm9sVGFibGUge1xuICBzdGF0aWMgdG9wKCk6IFByb2dyYW1TeW1ib2xUYWJsZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9ncmFtU3ltYm9sVGFibGUoKTtcbiAgfVxuXG4gIGFic3RyYWN0IGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuO1xuICBhYnN0cmFjdCBnZXQobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuXG4gIGFic3RyYWN0IGdldExvY2Fsc01hcCgpOiBEaWN0PG51bWJlcj47XG4gIGFic3RyYWN0IGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm87XG5cbiAgYWJzdHJhY3QgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gIGFic3RyYWN0IGFsbG9jYXRlQmxvY2sobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICBhYnN0cmFjdCBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgY2hpbGQobG9jYWxzOiBzdHJpbmdbXSk6IEJsb2NrU3ltYm9sVGFibGUge1xuICAgIGxldCBzeW1ib2xzID0gbG9jYWxzLm1hcChuYW1lID0+IHRoaXMuYWxsb2NhdGUobmFtZSkpO1xuICAgIHJldHVybiBuZXcgQmxvY2tTeW1ib2xUYWJsZSh0aGlzLCBsb2NhbHMsIHN5bWJvbHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtU3ltYm9sVGFibGUgZXh0ZW5kcyBTeW1ib2xUYWJsZSB7XG4gIHB1YmxpYyBzeW1ib2xzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIHByaXZhdGUgc2l6ZSA9IDE7XG4gIHByaXZhdGUgbmFtZWQgPSBkaWN0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBibG9ja3MgPSBkaWN0PG51bWJlcj4oKTtcblxuICBoYXMoX25hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldChfbmFtZTogc3RyaW5nKTogbmV2ZXIge1xuICAgIHRocm93IHVucmVhY2hhYmxlKCk7XG4gIH1cblxuICBnZXRMb2NhbHNNYXAoKTogRGljdDxudW1iZXI+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBnZXRFdmFsSW5mbygpOiBDb3JlLkV2YWxJbmZvIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXTtcblxuICAgIGlmICghbmFtZWQpIHtcbiAgICAgIG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXSA9IHRoaXMuYWxsb2NhdGUobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVkO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmIChuYW1lID09PSAnaW52ZXJzZScpIHtcbiAgICAgIG5hbWUgPSAnZWxzZSc7XG4gICAgfVxuXG4gICAgbGV0IGJsb2NrID0gdGhpcy5ibG9ja3NbbmFtZV07XG5cbiAgICBpZiAoIWJsb2NrKSB7XG4gICAgICBibG9jayA9IHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5hbGxvY2F0ZShgJiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHRoaXMuc3ltYm9scy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIHJldHVybiB0aGlzLnNpemUrKztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnQ6IFN5bWJvbFRhYmxlLCBwdWJsaWMgc3ltYm9sczogc3RyaW5nW10sIHB1YmxpYyBzbG90czogbnVtYmVyW10pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHwgdGhpcy5wYXJlbnQuaGFzKG5hbWUpO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IHNsb3QgPSB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2xvdCA9PT0gLTEgPyB0aGlzLnBhcmVudC5nZXQobmFtZSkgOiB0aGlzLnNsb3RzW3Nsb3RdO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgbGV0IGRpY3QgPSB0aGlzLnBhcmVudC5nZXRMb2NhbHNNYXAoKTtcbiAgICB0aGlzLnN5bWJvbHMuZm9yRWFjaChzeW1ib2wgPT4gKGRpY3Rbc3ltYm9sXSA9IHRoaXMuZ2V0KHN5bWJvbCkpKTtcbiAgICByZXR1cm4gZGljdDtcbiAgfVxuXG4gIGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm8ge1xuICAgIGxldCBsb2NhbHMgPSB0aGlzLmdldExvY2Fsc01hcCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2NhbHMpLm1hcChzeW1ib2wgPT4gbG9jYWxzW3N5bWJvbF0pO1xuICB9XG5cbiAgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZUJsb2NrKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGUoaWRlbnRpZmllcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYWxsb2NhdGUoaWRlbnRpZmllcik7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBpbiBhbiBBU1QgYW5kIG91dHB1dHMgYSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgY29uc3VtZWRcbiAqIGJ5IGEgY29tcGlsZXIuIEZvciBleGFtcGxlLCB0aGUgdGVtcGxhdGVcbiAqXG4gKiAgICAgZm9ve3tiYXJ9fTxkaXY+YmF6PC9kaXY+XG4gKlxuICogcHJvZHVjZXMgdGhlIGFjdGlvbnNcbiAqXG4gKiAgICAgW1snc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgM11dLFxuICogICAgICBbJ211c3RhY2hlJywgW211c3RhY2hlTm9kZSwgMSwgM11dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAyLCAzLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMiwgM10sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyB0aGUgQVNUIGRlcHRoIGZpcnN0IGFuZCBiYWNrd2FyZHMuIEFzXG4gKiBhIHJlc3VsdCB0aGUgYm90dG9tLW1vc3QgY2hpbGQgdGVtcGxhdGUgd2lsbCBhcHBlYXIgYXQgdGhlXG4gKiB0b3Agb2YgdGhlIGFjdGlvbnMgbGlzdCB3aGVyZWFzIHRoZSByb290IHRlbXBsYXRlIHdpbGwgYXBwZWFyXG4gKiBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0LiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgPGRpdj57eyNpZn19Zm9ve3tlbHNlfX1iYXI8Yj48L2I+e3svaWZ9fTwvZGl2PlxuICpcbiAqIHByb2R1Y2VzIHRoZSBhY3Rpb25zXG4gKlxuICogICAgIFtbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDIsIDBdXSxcbiAqICAgICAgWydvcGVuRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMiwgMF1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMl1dLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXSxcbiAqICAgICAgWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dLFxuICogICAgICBbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMl1dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxLCAxXV0sXG4gKiAgICAgIFsnYmxvY2snLCBbYmxvY2tOb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnY2xvc2VFbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIGlzIG1haW50YWluZWQgYnkgYSBzdGFjayBvZiBmcmFtZXMuXG4gKiBXaGVuZXZlciBhIG5vZGUgd2l0aCBjaGlsZHJlbiBpcyBlbnRlcmVkIChlaXRoZXIgYSBQcm9ncmFtTm9kZVxuICogb3IgYW4gRWxlbWVudE5vZGUpIGEgZnJhbWUgaXMgcHVzaGVkIG9udG8gdGhlIHN0YWNrLiBUaGUgZnJhbWVcbiAqIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIG9mIHRoYXRcbiAqIG5vZGUuIEZvciBleGFtcGxlLFxuICpcbiAqICAgLSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGlsZCBub2RlIGJlaW5nIHZpc2l0ZWRcbiAqICAgLSB0aGUgbnVtYmVyIG9mIG11c3RhY2hlcyBjb250YWluZWQgd2l0aGluIGl0cyBjaGlsZCBub2Rlc1xuICogICAtIHRoZSBsaXN0IG9mIGFjdGlvbnMgZ2VuZXJhdGVkIGJ5IGl0cyBjaGlsZCBub2Rlc1xuICovXG5cbmNsYXNzIEZyYW1lIHtcbiAgcHVibGljIHBhcmVudE5vZGU6IE9wdGlvbjxPYmplY3Q+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBPcHRpb248QVNULk5vZGVbXT4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRJbmRleDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRDb3VudDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRUZW1wbGF0ZUNvdW50ID0gMDtcbiAgcHVibGljIG11c3RhY2hlQ291bnQgPSAwO1xuICBwdWJsaWMgYWN0aW9uczogQWN0aW9uW10gPSBbXTtcbiAgcHVibGljIGJsYW5rQ2hpbGRUZXh0Tm9kZXM6IE9wdGlvbjxudW1iZXJbXT4gPSBudWxsO1xuICBwdWJsaWMgc3ltYm9sczogT3B0aW9uPEFTVC5TeW1ib2xzPiA9IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQWN0aW9uIHtcbiAgZXhwb3J0IHR5cGUgU3RhcnRQcm9ncmFtID0gWydzdGFydFByb2dyYW0nLCBbQVNULlRlbXBsYXRlLCBudW1iZXIsIG51bWJlcltdXV07XG4gIGV4cG9ydCB0eXBlIEVuZFByb2dyYW0gPSBbJ2VuZFByb2dyYW0nLCBbQVNULlRlbXBsYXRlLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgU3RhcnRCbG9jayA9IFsnc3RhcnRCbG9jaycsIFtBU1QuQmxvY2ssIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgRW5kQmxvY2sgPSBbJ2VuZEJsb2NrJywgW0FTVC5CbG9jaywgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIEJsb2NrID0gWydibG9jaycsIFtBU1QuQmxvY2tTdGF0ZW1lbnQsIG51bWJlciwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIE11c3RhY2hlID0gW1xuICAgICdtdXN0YWNoZScsXG4gICAgW0FTVC5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVC5QYXJ0aWFsU3RhdGVtZW50LCBudW1iZXIsIG51bWJlcl1cbiAgXTtcbiAgZXhwb3J0IHR5cGUgT3BlbkVsZW1lbnQgPSBbJ29wZW5FbGVtZW50JywgW0FTVC5FbGVtZW50Tm9kZSwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgQ2xvc2VFbGVtZW50ID0gWydjbG9zZUVsZW1lbnQnLCBbQVNULkVsZW1lbnROb2RlLCBudW1iZXIsIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBUZXh0ID0gWyd0ZXh0JywgW0FTVC5UZXh0Tm9kZSwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgQ29tbWVudCA9IFsnY29tbWVudCcsIFtBU1QuQ29tbWVudFN0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXTtcblxuICBleHBvcnQgdHlwZSBBY3Rpb24gPVxuICAgIHwgU3RhcnRQcm9ncmFtXG4gICAgfCBFbmRQcm9ncmFtXG4gICAgfCBTdGFydEJsb2NrXG4gICAgfCBFbmRCbG9ja1xuICAgIHwgQmxvY2tcbiAgICB8IE11c3RhY2hlXG4gICAgfCBPcGVuRWxlbWVudFxuICAgIHwgQ2xvc2VFbGVtZW50XG4gICAgfCBUZXh0XG4gICAgfCBDb21tZW50O1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb24gPSBBY3Rpb24uQWN0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZVZpc2l0b3Ige1xuICBwcml2YXRlIGZyYW1lU3RhY2s6IEZyYW1lW10gPSBbXTtcbiAgcHVibGljIGFjdGlvbnM6IEFjdGlvbltdID0gW107XG4gIHByaXZhdGUgcHJvZ3JhbURlcHRoID0gLTE7XG5cbiAgdmlzaXQ8UyBleHRlbmRzIEFTVC5Ub3BMZXZlbFN0YXRlbWVudD4obm9kZTogUykge1xuICAgICh0aGlzW25vZGUudHlwZV0gYXMgKHRoaXM6IHRoaXMsIG5vZGU6IFMpID0+IHZvaWQpKG5vZGUpO1xuICB9XG5cbiAgLy8gVHJhdmVyc2FsIG1ldGhvZHNcblxuICBCbG9jayhwcm9ncmFtOiBBU1QuQmxvY2spIHtcbiAgICByZXR1cm4gdGhpcy5hbnlCbG9jayhwcm9ncmFtKTtcbiAgfVxuXG4gIFRlbXBsYXRlKHByb2dyYW06IEFTVC5UZW1wbGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmFueUJsb2NrKHByb2dyYW0pO1xuICB9XG5cbiAgYW55QmxvY2socHJvZ3JhbTogQVNULkJsb2NrIHwgQVNULlRlbXBsYXRlKSB7XG4gICAgdGhpcy5wcm9ncmFtRGVwdGgrKztcblxuICAgIGxldCBwYXJlbnRGcmFtZSA9IHRoaXMuZ2V0Q3VycmVudEZyYW1lKCk7XG4gICAgbGV0IHByb2dyYW1GcmFtZSA9IHRoaXMucHVzaEZyYW1lKCk7XG5cbiAgICBpZiAoIXBhcmVudEZyYW1lKSB7XG4gICAgICAocHJvZ3JhbSBhcyBBU1QuVGVtcGxhdGUpLnN5bWJvbHMgPSBTeW1ib2xUYWJsZS50b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHByb2dyYW0gYXMgQVNULkJsb2NrKS5zeW1ib2xzID0gcGFyZW50RnJhbWUuc3ltYm9scyEuY2hpbGQocHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0VHlwZTogc3RyaW5nLCBlbmRUeXBlOiBzdHJpbmc7XG5cbiAgICBpZiAodGhpcy5wcm9ncmFtRGVwdGggPT09IDApIHtcbiAgICAgIHN0YXJ0VHlwZSA9ICdzdGFydFByb2dyYW0nO1xuICAgICAgZW5kVHlwZSA9ICdlbmRQcm9ncmFtJztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUeXBlID0gJ3N0YXJ0QmxvY2snO1xuICAgICAgZW5kVHlwZSA9ICdlbmRCbG9jayc7XG4gICAgfVxuXG4gICAgcHJvZ3JhbUZyYW1lLnBhcmVudE5vZGUgPSBwcm9ncmFtO1xuICAgIHByb2dyYW1GcmFtZS5jaGlsZHJlbiA9IHByb2dyYW0uYm9keTtcbiAgICBwcm9ncmFtRnJhbWUuY2hpbGRDb3VudCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG4gICAgcHJvZ3JhbUZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMgPSBbXTtcbiAgICBwcm9ncmFtRnJhbWUuYWN0aW9ucy5wdXNoKFtlbmRUeXBlLCBbcHJvZ3JhbSwgdGhpcy5wcm9ncmFtRGVwdGhdXSBhcyBBY3Rpb24pO1xuICAgIHByb2dyYW1GcmFtZS5zeW1ib2xzID0gcHJvZ3JhbVsnc3ltYm9scyddITtcblxuICAgIGZvciAobGV0IGkgPSBwcm9ncmFtLmJvZHkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHByb2dyYW1GcmFtZS5jaGlsZEluZGV4ID0gaTtcbiAgICAgIHRoaXMudmlzaXQocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICBwcm9ncmFtRnJhbWUuYWN0aW9ucy5wdXNoKFtcbiAgICAgIHN0YXJ0VHlwZSxcbiAgICAgIFtwcm9ncmFtLCBwcm9ncmFtRnJhbWUuY2hpbGRUZW1wbGF0ZUNvdW50LCBwcm9ncmFtRnJhbWUuYmxhbmtDaGlsZFRleHROb2Rlcy5yZXZlcnNlKCldLFxuICAgIF0gYXMgQWN0aW9uKTtcbiAgICB0aGlzLnBvcEZyYW1lKCk7XG5cbiAgICB0aGlzLnByb2dyYW1EZXB0aC0tO1xuXG4gICAgLy8gUHVzaCB0aGUgY29tcGxldGVkIHRlbXBsYXRlIGludG8gdGhlIGdsb2JhbCBhY3Rpb25zIGxpc3RcbiAgICBpZiAocGFyZW50RnJhbWUpIHtcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCsrO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnMucHVzaCguLi5wcm9ncmFtRnJhbWUuYWN0aW9ucy5yZXZlcnNlKCkpO1xuICB9XG5cbiAgRWxlbWVudE5vZGUoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IHBhcmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgbGV0IGVsZW1lbnRGcmFtZSA9IHRoaXMucHVzaEZyYW1lKCk7XG5cbiAgICBlbGVtZW50RnJhbWUucGFyZW50Tm9kZSA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudEZyYW1lLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICBlbGVtZW50RnJhbWUuY2hpbGRDb3VudCA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50ICs9IGVsZW1lbnQubW9kaWZpZXJzLmxlbmd0aDtcbiAgICBlbGVtZW50RnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyA9IFtdO1xuICAgIGVsZW1lbnRGcmFtZS5zeW1ib2xzID0gZWxlbWVudC5zeW1ib2xzID0gcGFyZW50RnJhbWUuc3ltYm9scyEuY2hpbGQoZWxlbWVudC5ibG9ja1BhcmFtcyk7XG5cbiAgICBsZXQgYWN0aW9uQXJnczogW0FTVC5FbGVtZW50Tm9kZSwgbnVtYmVyLCBudW1iZXJdID0gW1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkSW5kZXghLFxuICAgICAgcGFyZW50RnJhbWUuY2hpbGRDb3VudCEsXG4gICAgXTtcblxuICAgIGVsZW1lbnRGcmFtZS5hY3Rpb25zLnB1c2goWydjbG9zZUVsZW1lbnQnLCBhY3Rpb25BcmdzXSk7XG5cbiAgICBmb3IgKGxldCBpID0gZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnZpc2l0KGVsZW1lbnQuYXR0cmlidXRlc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGVsZW1lbnRGcmFtZS5jaGlsZEluZGV4ID0gaTtcbiAgICAgIHRoaXMudmlzaXQoZWxlbWVudC5jaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgbGV0IG9wZW4gPSBbXG4gICAgICAnb3BlbkVsZW1lbnQnLFxuICAgICAgWy4uLmFjdGlvbkFyZ3MsIGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50LCBlbGVtZW50RnJhbWUuYmxhbmtDaGlsZFRleHROb2Rlcy5yZXZlcnNlKCldLFxuICAgIF0gYXMgQWN0aW9uLk9wZW5FbGVtZW50O1xuICAgIGVsZW1lbnRGcmFtZS5hY3Rpb25zLnB1c2gob3Blbik7XG5cbiAgICB0aGlzLnBvcEZyYW1lKCk7XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIGVsZW1lbnQncyBmcmFtZSBzdGF0ZSB0byB0aGUgcGFyZW50IGZyYW1lXG4gICAgaWYgKGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50ID4gMCkge1xuICAgICAgcGFyZW50RnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIH1cbiAgICBwYXJlbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQgKz0gZWxlbWVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudDtcbiAgICBwYXJlbnRGcmFtZS5hY3Rpb25zLnB1c2goLi4uZWxlbWVudEZyYW1lLmFjdGlvbnMpO1xuICB9XG5cbiAgQXR0ck5vZGUoYXR0cjogQVNULkF0dHJOb2RlKSB7XG4gICAgaWYgKGF0dHIudmFsdWUudHlwZSAhPT0gJ1RleHROb2RlJykge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIFRleHROb2RlKHRleHQ6IEFTVC5UZXh0Tm9kZSkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0ZXh0LmNoYXJzID09PSAnJykge1xuICAgICAgZnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyEucHVzaChkb21JbmRleE9mKGZyYW1lLmNoaWxkcmVuISwgdGV4dCkpO1xuICAgIH1cbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWyd0ZXh0JywgW3RleHQsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQobm9kZTogQVNULkJsb2NrU3RhdGVtZW50KSB7XG4gICAgbGV0IGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cbiAgICBmcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsnYmxvY2snLCBbbm9kZSwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG5cbiAgICBpZiAobm9kZS5pbnZlcnNlKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGUuaW52ZXJzZSk7XG4gICAgfVxuICAgIGlmIChub2RlLnByb2dyYW0pIHtcbiAgICAgIHRoaXMudmlzaXQobm9kZS5wcm9ncmFtKTtcbiAgICB9XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KG5vZGU6IEFTVC5QYXJ0aWFsU3RhdGVtZW50KSB7XG4gICAgbGV0IGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ211c3RhY2hlJywgW25vZGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudCh0ZXh0OiBBU1QuQ29tbWVudFN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2NvbW1lbnQnLCBbdGV4dCwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH1cblxuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQoKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgZW1wdHk6IEhhbmRsZWJhcnMgY29tbWVudHMgc2hvdWxkIG5vdCBhZmZlY3Qgb3V0cHV0LlxuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQobXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydtdXN0YWNoZScsIFttdXN0YWNoZSwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH1cblxuICAvLyBGcmFtZSBoZWxwZXJzXG5cbiAgcHJpdmF0ZSBnZXQgY3VycmVudEZyYW1lKCk6IEZyYW1lIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZ2V0Q3VycmVudEZyYW1lKCksICdFeHBlY3RlZCBhIGN1cnJlbnQgZnJhbWUnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q3VycmVudEZyYW1lKCk6IE9wdGlvbjxGcmFtZT4ge1xuICAgIHJldHVybiB0aGlzLmZyYW1lU3RhY2tbdGhpcy5mcmFtZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoRnJhbWUoKSB7XG4gICAgbGV0IGZyYW1lID0gbmV3IEZyYW1lKCk7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnB1c2goZnJhbWUpO1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgcG9wRnJhbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVTdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiBgZG9tTm9kZWAgaW4gdGhlIGBub2Rlc2AgYXJyYXksIHNraXBwaW5nXG4vLyBvdmVyIGFueSBub2RlcyB3aGljaCBkbyBub3QgcmVwcmVzZW50IERPTSBub2Rlcy5cbmZ1bmN0aW9uIGRvbUluZGV4T2Yobm9kZXM6IEFTVC5Ob2RlW10sIGRvbU5vZGU6IEFTVC5UZXh0Tm9kZSB8IEFTVC5FbGVtZW50Tm9kZSkge1xuICBsZXQgaW5kZXggPSAtMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChub2RlLnR5cGUgIT09ICdUZXh0Tm9kZScgJiYgbm9kZS50eXBlICE9PSAnRWxlbWVudE5vZGUnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=