import { DictSet, Option } from '@glimmer/util';
import { AST } from '@glimmer/syntax';
import { CompileOptions } from './template-compiler';
import { Processor, CompilerOps, OpName, Op } from './compiler-ops';
import { WireFormat, SerializedInlineBlock, Statement, SerializedTemplateBlock, Statements, Expression, Expressions } from '@glimmer/interfaces';
export declare type str = string;
import Core = WireFormat.Core;
export declare type Params = WireFormat.Core.Params;
export declare type Hash = WireFormat.Core.Hash;
export declare type Path = WireFormat.Core.Path;
export declare type StackValue = WireFormat.Expression | Params | Hash | str;
export declare abstract class Block {
    statements: WireFormat.Statement[];
    abstract toJSON(): Object;
    push(statement: WireFormat.Statement): void;
}
export declare class InlineBlock extends Block {
    table: AST.BlockSymbols;
    constructor(table: AST.BlockSymbols);
    toJSON(): SerializedInlineBlock;
}
export declare class NamedBlock extends InlineBlock {
    name: string;
    constructor(name: string, table: AST.BlockSymbols);
}
export declare class TemplateBlock extends Block {
    private symbolTable;
    type: string;
    yields: DictSet<string>;
    named: DictSet<string>;
    blocks: SerializedInlineBlock[];
    hasEval: boolean;
    constructor(symbolTable: AST.Symbols);
    push(statement: Statement): void;
    toJSON(): SerializedTemplateBlock;
}
export declare class ComponentBlock extends Block {
    private tag;
    private table;
    private selfClosing;
    attributes: Statements.Attribute[];
    arguments: Statements.Argument[];
    private inParams;
    positionals: number[];
    blocks: Array<[string, SerializedInlineBlock]>;
    constructor(tag: string, table: AST.BlockSymbols, selfClosing: boolean);
    push(statement: Statement): void;
    pushBlock(name: string, block: SerializedInlineBlock): void;
    toJSON(): [string, Statements.Attribute[], Core.Hash, Core.Blocks];
}
export declare class Template {
    block: TemplateBlock;
    constructor(symbols: AST.Symbols);
    toJSON(): SerializedTemplateBlock;
}
export declare type InVariable = number;
export declare type InOp<K extends keyof CompilerOps<InVariable> = OpName> = Op<InVariable, CompilerOps<InVariable>, K>;
export default class JavaScriptCompiler implements Processor<CompilerOps<number>, void, CompilerOps<void>> {
    static process(opcodes: InOp[], symbols: AST.Symbols, options?: CompileOptions): Template;
    private template;
    private blocks;
    private opcodes;
    private values;
    private options;
    constructor(opcodes: InOp[], symbols: AST.Symbols, options?: CompileOptions);
    readonly currentBlock: Block;
    readonly currentComponent: ComponentBlock;
    process(): Template;
    startBlock(program: AST.Block): void;
    endBlock(): void;
    startProgram(): void;
    endProgram(): void;
    text(content: string): void;
    append(trusted: boolean): void;
    comment(value: string): void;
    modifier(name: string): void;
    block([name, template, inverse]: [string, number, Option<number>]): void;
    openComponent(element: AST.ElementNode): void;
    openNamedBlock(element: AST.ElementNode): void;
    openElement([element, simple]: [AST.ElementNode, boolean]): void;
    flushElement(): void;
    closeComponent(_element: AST.ElementNode): void;
    closeNamedBlock(_element: AST.ElementNode): void;
    closeDynamicComponent(_element: AST.ElementNode): void;
    closeElement(_element: AST.ElementNode): void;
    staticAttr([name, namespace]: [string, Option<string>]): void;
    dynamicAttr([name, namespace]: [string, Option<string>]): void;
    componentAttr([name, namespace]: [string, Option<string>]): void;
    trustingAttr([name, namespace]: [string, Option<string>]): void;
    trustingComponentAttr([name, namespace]: [string, Option<string>]): void;
    staticArg(name: str): void;
    dynamicArg(name: str): void;
    yield(to: number): void;
    attrSplat(to: Option<number>): void;
    debugger(evalInfo: Option<Core.EvalInfo>): void;
    hasBlock(name: number): void;
    hasBlockParams(name: number): void;
    partial(evalInfo: Option<Core.EvalInfo>): void;
    literal(value: Expressions.Value | undefined): void;
    unknown(name: string): void;
    get([head, path]: [number, string[]]): void;
    maybeLocal(path: string[]): void;
    concat(): void;
    helper(name: string): void;
    prepareArray(size: number): void;
    prepareObject(size: number): void;
    endComponent(): [string, Statements.Attribute[], Core.Hash, Core.Blocks];
    startInlineBlock(symbols: AST.BlockSymbols): void;
    endInlineBlock(): SerializedInlineBlock;
    push(args: Statement): void;
    pushValue<S extends Expression | Params | Hash>(val: S): void;
    popValue<T extends StackValue>(): T;
}
//# sourceMappingURL=javascript-compiler.d.ts.map